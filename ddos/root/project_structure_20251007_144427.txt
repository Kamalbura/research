PROJECT STRUCTURE AND PYTHON FILES LOG
================================================================================
Root Directory: /home/prod/Desktop/ddos
Output File: /home/prod/Desktop/ddos/project_structure_20251007_144427.txt
Generated: 2025-10-07 14:44:27
================================================================================

================================================================================
DIRECTORY TREE STRUCTURE
================================================================================
Root Directory: /home/prod/Desktop/ddos
Generated: 2025-10-07 14:44:27

├── New folder/
├── Preprocessing/
│   ├── Data/
│   │   ├── combined/
│   │   │   ├── processed/
│   │   │   │   └── train_ddos_data_0.1.csv (238,332 bytes)
│   │   │   ├── test/
│   │   │   └── train/
│   │   │       ├── old/
│   │   │       ├── attack_2.csv (97,618,442 bytes)
│   │   │       ├── attack_4.csv (10,081,867 bytes)
│   │   │       ├── attack_4_udp.csv (7,665,036 bytes)
│   │   │       ├── normal_1.csv (17,085,555 bytes)
│   │   │       └── normal_3.csv (6,203,987 bytes)
│   │   ├── icmp/
│   │   │   ├── processed/
│   │   │   ├── test/
│   │   │   │   ├── fast/
│   │   │   │   │   ├── attack_2.csv (804,761 bytes)
│   │   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   │   ├── faster/
│   │   │   │   │   ├── attack_2.csv (926,462 bytes)
│   │   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   │   ├── flood/
│   │   │   │   │   ├── attack_2.csv (20,004,990 bytes)
│   │   │   │   │   └── normal_1.csv (4,553,124 bytes)
│   │   │   │   ├── attack_2.csv (804,761 bytes)
│   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   └── train/
│   │   │       ├── fast/
│   │   │       ├── faster/
│   │   │       └── flood/
│   │   ├── tcp/
│   │   │   ├── processed/
│   │   │   ├── test/
│   │   │   │   ├── fast/
│   │   │   │   │   ├── attack_2.csv (2,453,820 bytes)
│   │   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   │   ├── faster/
│   │   │   │   │   ├── attack_2.csv (7,909,914 bytes)
│   │   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   │   ├── flood/
│   │   │   │   │   ├── attack_2.csv (13,474,114 bytes)
│   │   │   │   │   └── normal_1.csv (4,553,124 bytes)
│   │   │   │   ├── attack_2.csv (2,453,820 bytes)
│   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   └── train/
│   │   │       ├── fast/
│   │   │       ├── faster/
│   │   │       └── flood/
│   │   ├── tcp_icmp/
│   │   │   ├── processed/
│   │   │   ├── test/
│   │   │   │   ├── fast/
│   │   │   │   ├── faster/
│   │   │   │   ├── flood/
│   │   │   │   └── normal_1.csv (3,008,299 bytes)
│   │   │   └── train/
│   │   │       ├── fast/
│   │   │       ├── faster/
│   │   │       └── flood/
│   │   └── udp/
│   │       ├── processed/
│   │       ├── test/
│   │       │   ├── attack_2.csv (4,656,179 bytes)
│   │       │   └── normal_1.csv (4,553,124 bytes)
│   │       └── train/
│   ├── Finaldata/
│   │   ├── icmp_test_ddos_data_0.1.csv (114,885 bytes)
│   │   ├── icmp_test_fast_ddos_data_0.1.csv (20,738 bytes)
│   │   ├── icmp_test_faster_ddos_data_0.1.csv (20,317 bytes)
│   │   ├── tcp_icmp_test_ddos_data_0.1.csv (111,742 bytes)
│   │   ├── tcp_test_ddos_data_0.1.csv (112,209 bytes)
│   │   ├── tcp_test_fast_ddos_data_0.1.csv (29,003 bytes)
│   │   ├── tcp_test_faster_ddos_data_0.1.csv (23,335 bytes)
│   │   └── train_ddos_data_0.1.csv (238,332 bytes)
│   └── pre_process.py (5,949 bytes)
├── evaluation/
│   └── tst/
│       ├── models/
│       │   ├── dim_ff/
│       │   │   ├── 400_64_32_128_2_0.1_0.1_entire_model.pth (507,896 bytes)
│       │   │   ├── 400_64_32_32_2_0.1_0.1_entire_model.pth (408,769 bytes)
│       │   │   └── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   ├── dim_model/
│       │   │   ├── 400_128_32_64_2_0.1_0.1_entire_model.pth (1,112,568 bytes)
│       │   │   ├── 400_256_32_64_2_0.1_0.1_entire_model.pth (3,240,632 bytes)
│       │   │   ├── 400_512_32_64_2_0.1_0.1_entire_model.pth (10,642,104 bytes)
│       │   │   └── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   ├── num_encoders/
│       │   │   ├── 400_64_32_64_1_0.1_0.1_entire_model.pth (326,850 bytes)
│       │   │   ├── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   │   └── 400_64_32_64_3_0.1_0.1_entire_model.pth (556,736 bytes)
│       │   ├── num_heads/
│       │   │   ├── 400_64_16_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   │   ├── 400_64_16_64_2_0.1_0.1_results.txt (13,964 bytes)
│       │   │   ├── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   │   ├── 400_64_32_64_2_0.1_0.1_results.txt (13,715 bytes)
│       │   │   ├── 400_64_8_64_2_0.1_0.1_entire_model.pth (441,738 bytes)
│       │   │   └── 400_64_8_64_2_0.1_0.1_results.txt (13,817 bytes)
│       │   ├── num_layers/
│       │   │   ├── 400_64_32_64_1_0.1_0.1_entire_model.pth (326,850 bytes)
│       │   │   ├── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   │   └── 400_64_32_64_3_0.1_0.1_entire_model.pth (556,736 bytes)
│       │   ├── old/
│       │   │   ├── 100_entire_model.pth (935,084 bytes)
│       │   │   ├── 10_entire_model.pth (842,869 bytes)
│       │   │   ├── 140_128_16_entire_model.pth (779,821 bytes)
│       │   │   ├── 160_128_16_entire_model.pth (800,301 bytes)
│       │   │   ├── 180_128_16_entire_model.pth (820,781 bytes)
│       │   │   ├── 200_128_16_entire_model.pth (841,261 bytes)
│       │   │   ├── 220_128_16_entire_model.pth (861,796 bytes)
│       │   │   ├── 240_128_16_entire_model.pth (882,221 bytes)
│       │   │   ├── 260_128_16_entire_model.pth (902,701 bytes)
│       │   │   ├── 280_128_16_entire_model.pth (923,181 bytes)
│       │   │   ├── 280_entire_model.pth (922,028 bytes)
│       │   │   ├── 30_entire_model.pth (863,349 bytes)
│       │   │   ├── 330_128_16_entire_model.pth (974,381 bytes)
│       │   │   ├── 5_entire_model.pth (837,694 bytes)
│       │   │   ├── 60_entire_model.pth (894,069 bytes)
│       │   │   └── 80_entire_model.pth (914,549 bytes)
│       │   ├── seq_len/
│       │   │   ├── 100_64_32_64_2_0.1_0.1_entire_model.pth (287,489 bytes)
│       │   │   ├── 200_64_32_64_2_0.1_0.1_entire_model.pth (338,689 bytes)
│       │   │   ├── 300_64_32_64_2_0.1_0.1_entire_model.pth (389,889 bytes)
│       │   │   ├── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   │   └── 500_64_32_64_2_0.1_0.1_entire_model.pth (492,993 bytes)
│       │   ├── 400_64_32_64_1_0.1_0.1_entire_model.pth (326,850 bytes)
│       │   ├── 400_64_32_64_2_0.1_0.1_entire_model.pth (441,793 bytes)
│       │   └── 400_64_32_64_3_0.1_0.1_entire_model.pth (556,736 bytes)
│       └── performance/
│           ├── __pycache__/
│           │   ├── tstplus.cpython-311.pyc (22,518 bytes)
│           │   └── tstplus.cpython-39.pyc (13,098 bytes)
│           ├── test_tst.py (4,973 bytes)
│           └── tstplus.py (17,194 bytes)
├── log_folder.py (8,644 bytes)
└── project_structure_20251007_144427.txt (8,176 bytes)


================================================================================
PYTHON FILE CONTENTS
================================================================================

Found 4 Python files:
   1. Preprocessing/pre_process.py
   2. evaluation/tst/performance/test_tst.py
   3. evaluation/tst/performance/tstplus.py
   4. log_folder.py

--------------------------------------------------------------------------------

FILE 1/4: Preprocessing/pre_process.py
============================================================
Full Path: /home/prod/Desktop/ddos/Preprocessing/pre_process.py
Size: 5,949 bytes
Modified: 2024-02-24 12:11:26
------------------------------------------------------------
import os
import pandas as pd


def process_file(file_name, simple_name, lim_dict, window=0.25):
    try:
        if "normal" in file_name:
            status = 0
        else:
            status = 1
        df = pd.read_csv(file_name)
        df_filtered = df[["Time", "Protocol", "Length"]]
        t_min = df_filtered["Time"].min()
        # min(df_filtered["Time"].max(), lim_dict[simple_name])
        t_max = df_filtered["Time"].max()
        mavlink_packets = []
        total_length = []
        curr_time = t_min
        while curr_time < t_max:

            filtered_df = df_filtered[(df_filtered["Time"] >= curr_time) & (
                df_filtered["Time"] < curr_time + window)]

            # Total Length
            t_length = int((filtered_df[["Length"]].sum()).iloc[0])
            total_length.append(t_length)

            # Packet_count
            p_count = int(
                ((filtered_df[["Protocol"]] == "MAVLink 2.0").sum()).iloc[0])
            mavlink_packets.append(p_count)

            # Update Time
            curr_time += window

        df_processed = pd.DataFrame(
            {"Total_length": total_length, "Mavlink_Count": mavlink_packets})
        df_processed["Status"] = status
        return df_processed
    except Exception as E:
        print("Error: ", E)
        return pd.DataFrame()


def gen_data(file_paths, attack, mode, window_size):
    # Initialize an empty list to store aggregated DataFrames
    aggregated_dfs = []
    lim_dict = {}
    print("Generating ", attack, " ", mode, " data")

    attack_files = [
        "attack_" + str(i*2) + ".csv" for i in range(1, len(file_paths)//2 + 1)]
    normal_files = ["normal_" +
                    str(1 + i*2) + ".csv" for i in range(len(file_paths)//2)]

    # Iterate over each file path
    for file_path in file_paths:
        count = len(file_paths)//2
        for elem in range(count):
            attack_file_tem = os.path.join(os.path.dirname(
                os.path.abspath(__file__)), "Data", attack, mode, attack_files[elem])
            normal_file_tem = os.path.join(os.path.dirname(
                os.path.abspath(__file__)), "Data", attack, mode, normal_files[elem])

            temp_max_elems = min((pd.read_csv(attack_file_tem))["Time"].max(), (
                pd.read_csv(normal_file_tem))["Time"].max())
            lim_dict[attack_files[elem]] = temp_max_elems
            lim_dict[normal_files[elem]] = temp_max_elems

    for file_name in file_paths:
        print("processing: ", file_name)
        # Process the file and get the aggregated DataFrame
        file_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), "Data", attack, mode, file_name)
        aggregated_df = process_file(
            file_path, file_name, lim_dict, window_size)
        if aggregated_df is not None:
            # Add the aggregated DataFrame to the list
            aggregated_dfs.append(aggregated_df)

    # Concatenate all aggregated DataFrames into a single DataFrame
    final_df = pd.concat(aggregated_dfs)
    final_df.to_csv(os.path.join(os.path.dirname(
        os.path.abspath(__file__)), "Data", attack, "processed", attack + "_" + mode + '_ddos_data_' + str(window_size) + '.csv'))


def gen_data_combined(file_paths, mode, window_size):
    # Initialize an empty list to store aggregated DataFrames
    aggregated_dfs = []
    lim_dict = {}
    print("Generating ", mode, " data")

    attack_files = [
        "attack_" + str(i*2) + ".csv" for i in range(1, len(file_paths)//2 + 1)]
    normal_files = ["normal_" +
                    str(1 + i*2) + ".csv" for i in range(len(file_paths)//2)]

    # Iterate over each file path
    for file_path in file_paths:
        count = len(file_paths)//2
        for elem in range(count):
            attack_file_tem = os.path.join(os.path.dirname(
                os.path.abspath(__file__)), "Data", "combined", mode, attack_files[elem])
            normal_file_tem = os.path.join(os.path.dirname(
                os.path.abspath(__file__)), "Data", "combined", mode, normal_files[elem])

            temp_max_elems = min((pd.read_csv(attack_file_tem))["Time"].max(), (
                pd.read_csv(normal_file_tem))["Time"].max())
            lim_dict[attack_files[elem]] = temp_max_elems
            lim_dict[normal_files[elem]] = temp_max_elems

    for file_name in file_paths:
        print("processing: ", file_name)
        # Process the file and get the aggregated DataFrame
        file_path = os.path.join(os.path.dirname(
            os.path.abspath(__file__)), "Data", "combined", mode, file_name)
        aggregated_df = process_file(
            file_path, file_name, lim_dict, window_size)
        if aggregated_df is not None:
            # Add the aggregated DataFrame to the list
            aggregated_dfs.append(aggregated_df)

    # Concatenate all aggregated DataFrames into a single DataFrame
    final_df = pd.concat(aggregated_dfs)
    final_df.to_csv(os.path.join(os.path.dirname(
        os.path.abspath(__file__)), "Data", "combined", "processed", mode + '_ddos_data_' + str(window_size) + '.csv'))


def run():
    window_size = 0.1  # Window size in seconds

    train_file_paths = ['normal_1.csv', 'attack_2.csv', 'normal_3.csv', 'attack_4.csv',
                        ]  # 'normal_7.csv', 'attack_8.csv' 'normal_1.csv', 'attack_2.csv', 'normal_5.csv', 'attack_6.csv',

    test_file_paths = ['normal_1.csv', 'attack_2.csv']

    attacks = ["icmp"]  # ["tcp", "icmp"]

    # gen_data_combined(train_file_paths, "train", window_size)
    # gen_data_combined(test_file_paths, "test", window_size)

    for attack in attacks:
        # gen_data(train_file_paths, attack, "train", window_size)
        gen_data(test_file_paths, attack, "test", window_size)
        pass


run()

============================================================

FILE 2/4: evaluation/tst/performance/test_tst.py
============================================================
Full Path: /home/prod/Desktop/ddos/evaluation/tst/performance/test_tst.py
Size: 4,973 bytes
Modified: 2024-06-15 13:08:32
------------------------------------------------------------
import os
import time
import torch
import pandas as pd
import numpy as np
from statistics import mode
from memory_profiler import profile
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report
from torch.utils.data import DataLoader, TensorDataset
from tstplus import _TSTEncoderLayer, _TSTEncoder, _TSTBackbone, TSTPlus


ddos_dir = os.path.dirname(os.path.dirname(
    os.path.dirname(os.path.dirname(__file__))))
data_dir = os.path.join(ddos_dir, "Preprocessing", "Finaldata")
models_dir = os.path.join(ddos_dir, "evaluation", "tst", "models")
output_dir = os.path.join(ddos_dir, "evaluation",
                          "tst", "results", "performance")


@profile(precision=8)
def load_model(model_name):
    model = torch.load(model_name, map_location=torch.device('cpu'))
    return model


def create_sequences(data, seq_length):
    xs = []
    ys = []

    for i in range(len(data) - seq_length):
        x = data['Mavlink_Count'].iloc[i:(i + seq_length)].values
        # y = data['Status'].iloc[i + seq_length]
        y = mode(data['Status'].iloc[i: i + seq_length + 1].values)
        xs.append(x)
        ys.append(y)

    return np.array(xs), np.array(ys)


# @profile(precision=8)
def get_prediction_time(model, dataloader):
    model.eval()  # Set the model to evaluation mode
    total_time = 0
    total_records = 0
    while True:
        print("running at time = ", time.time())
        with torch.no_grad():
            for inputs, _ in dataloader:
                start_time = time.time()
                outputs = model(inputs)
                end_time = time.time()

                #batch_time = end_time - start_time
                #total_time += batch_time
                #total_records += len(inputs)

    average_time = total_time / total_records
    print("Total time is : ", total_time)
    print("Total Records are : ", total_records)
    return average_time


def evaluate_model(model, dataloader, thres=0.8):
    model.eval()
    true_labels = []
    predictions = []
    
    with torch.no_grad():
        for xb, yb in dataloader:
            outputs = model(xb)
            outputs = outputs.squeeze()
            probabilities = torch.sigmoid(outputs)
            predicted_labels = (probabilities >= thres).long()

            true_labels.extend(yb.tolist())
            predictions.extend(predicted_labels.tolist())

    report = classification_report(true_labels, predictions, output_dict=True)
    return report


def dry_run(model, file_name, scaler):

    # '/content/test_ddos_data_0.1.csv' #os.path.join(path, 'test_ddos_data_' + str(window) + '.csv')  # Replace with your test file path
    test_file_path = os.path.join(data_dir, file_name)
    test_data = pd.read_csv(test_file_path)

    # Normalizing the 'c4' column in test data (using the same scaler as the training set)
    test_data[['Mavlink_Count', 'Total_length']] = scaler.transform(
        test_data[['Mavlink_Count', 'Total_length']])

    X_test, y_test = create_sequences(test_data, 400)
    X_test_tensor = torch.tensor(X_test).float().unsqueeze(1)
    y_test_tensor = torch.tensor(y_test).float()
    test_dataset = TensorDataset(X_test_tensor, y_test_tensor)
    test_udp_dataloader = DataLoader(
        test_dataset, batch_size=4, shuffle=True, drop_last=True)

    prediction_time = get_prediction_time(model, test_udp_dataloader)
    print("Average Prediction Time per Record for  : ",
          file_name, " is ", prediction_time, " seconds")
    report = {}
    #for t_p in [0.3, 0.35, 0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9]:
    #    report[t_p] = evaluate_model(model, test_udp_dataloader, thres=t_p)

    #o_p_filename = os.path.join(output_dir, file_name + "_results.txt")
    #with open(o_p_filename, 'w') as f:
    #    for key, value in report.items():
    #        f.write('%s:%s\n' % (key, value))


# List of test files
test_files = [
    'tcp_test_ddos_data_0.1.csv',
#    'icmp_test_ddos_data_0.1.csv',
#    'tcp_test_fast_ddos_data_0.1.csv',
#    'icmp_test_fast_ddos_data_0.1.csv',
#    'tcp_test_faster_ddos_data_0.1.csv',
#    'icmp_test_faster_ddos_data_0.1.csv',
#    'tcp_icmp_test_ddos_data_0.1.csv'
]

model = load_model(os.path.join(models_dir, "400_64_32_64_1_0.1_0.1_entire_model.pth"))

for file_path in test_files:
    print(f"Testing {file_path}...")
    bs = 4
    scaler = StandardScaler()
    # Load the training CSV file
    # os.path.join(path, 'train_ddos_data_'+ str(window) + '.csv')   # Replace with your file path
    train_file_path = os.path.join(data_dir, 'train_ddos_data_0.1.csv')
    train_data = pd.read_csv(train_file_path)

    # Normalizing the 'c4' column in training data
    scaler = StandardScaler()
    train_data[['Mavlink_Count', 'Total_length']] = scaler.fit_transform(
        train_data[['Mavlink_Count', 'Total_length']])

    dry_run(model, file_path, scaler)
    print("\n")  # Print newline for readability between tests

============================================================

FILE 3/4: evaluation/tst/performance/tstplus.py
============================================================
Full Path: /home/prod/Desktop/ddos/evaluation/tst/performance/tstplus.py
Size: 17,194 bytes
Modified: 2024-02-06 18:26:10
------------------------------------------------------------
from typing import Callable
from tsai.imports import *
from tsai.utils import *
from tsai.models.layers import *
from tsai.models.utils import *
from tsai.models.positional_encoders import *
from tsai.data.core import *

"""## TST"""

class _TSTEncoderLayer(Module):
    def __init__(self, q_len, d_model, n_heads, d_k=None, d_v=None, d_ff=256, store_attn=False,
                 norm='BatchNorm', attn_dropout=0, dropout=0., bias=True, activation="gelu", res_attention=False, pre_norm=False):

        assert not d_model%n_heads, f"d_model ({d_model}) must be divisible by n_heads ({n_heads})"
        d_k = ifnone(d_k, d_model // n_heads)
        d_v = ifnone(d_v, d_model // n_heads)

        # Multi-Head attention
        self.res_attention = res_attention
        self.self_attn = MultiheadAttention(d_model, n_heads, d_k, d_v, attn_dropout=attn_dropout, proj_dropout=dropout, res_attention=res_attention)

        # Add & Norm
        self.dropout_attn = nn.Dropout(dropout)
        if "batch" in norm.lower():
            self.norm_attn = nn.Sequential(Transpose(1,2), nn.BatchNorm1d(d_model), Transpose(1,2))
        else:
            self.norm_attn = nn.LayerNorm(d_model)

        # Position-wise Feed-Forward
        self.ff = nn.Sequential(nn.Linear(d_model, d_ff, bias=bias),
                                get_act_fn(activation),
                                nn.Dropout(dropout),
                                nn.Linear(d_ff, d_model, bias=bias))

        # Add & Norm
        self.dropout_ffn = nn.Dropout(dropout)
        if "batch" in norm.lower():
            self.norm_ffn = nn.Sequential(Transpose(1,2), nn.BatchNorm1d(d_model), Transpose(1,2))
        else:
            self.norm_ffn = nn.LayerNorm(d_model)

        self.pre_norm = pre_norm
        self.store_attn = store_attn

    def forward(self, src:Tensor, prev:Optional[Tensor]=None, key_padding_mask:Optional[Tensor]=None, attn_mask:Optional[Tensor]=None) -> Tensor:

        # Multi-Head attention sublayer
        if self.pre_norm:
            src = self.norm_attn(src)
        ## Multi-Head attention
        if self.res_attention:
            src2, attn, scores = self.self_attn(src, src, src, prev, key_padding_mask=key_padding_mask, attn_mask=attn_mask)
        else:
            src2, attn = self.self_attn(src, src, src, key_padding_mask=key_padding_mask, attn_mask=attn_mask)
        if self.store_attn:
            self.attn = attn
        ## Add & Norm
        src = src + self.dropout_attn(src2) # Add: residual connection with residual dropout
        if not self.pre_norm:
            src = self.norm_attn(src)

        # Feed-forward sublayer
        if self.pre_norm:
            src = self.norm_ffn(src)
        ## Position-wise Feed-Forward
        src2 = self.ff(src)
        ## Add & Norm
        src = src + self.dropout_ffn(src2) # Add: residual connection with residual dropout
        if not self.pre_norm:
            src = self.norm_ffn(src)

        if self.res_attention:
            return src, scores
        else:
            return src

class _TSTEncoder(Module):
    def __init__(self, q_len, d_model, n_heads, d_k=None, d_v=None, d_ff=None, norm='BatchNorm', attn_dropout=0., dropout=0., activation='gelu',
                 res_attention=False, n_layers=1, pre_norm=False, store_attn=False):
        self.layers = nn.ModuleList([_TSTEncoderLayer(q_len, d_model, n_heads=n_heads, d_k=d_k, d_v=d_v, d_ff=d_ff, norm=norm,
                                                      attn_dropout=attn_dropout, dropout=dropout,
                                                      activation=activation, res_attention=res_attention,
                                                      pre_norm=pre_norm, store_attn=store_attn) for i in range(n_layers)])
        self.res_attention = res_attention

    def forward(self, src:Tensor, key_padding_mask:Optional[Tensor]=None, attn_mask:Optional[Tensor]=None):
        output = src
        scores = None
        if self.res_attention:
            for mod in self.layers: output, scores = mod(output, prev=scores, key_padding_mask=key_padding_mask, attn_mask=attn_mask)
            return output
        else:
            for mod in self.layers: output = mod(output, key_padding_mask=key_padding_mask, attn_mask=attn_mask)
            return output

#|exporti
class _TSTBackbone(Module):
    def __init__(self, c_in, seq_len, max_seq_len=512,
                 n_layers=3, d_model=128, n_heads=16, d_k=None, d_v=None,
                 d_ff=256, norm='BatchNorm', attn_dropout=0., dropout=0., act="gelu", store_attn=False,
                 key_padding_mask='auto', padding_var=None, attn_mask=None, res_attention=True, pre_norm=False,
                 pe='zeros', learn_pe=True, verbose=False, **kwargs):

        # Input encoding
        q_len = seq_len
        self.new_q_len = False
        if max_seq_len is not None and seq_len > max_seq_len: # Control temporal resolution
            self.new_q_len = True
            q_len = max_seq_len
            tr_factor = math.ceil(seq_len / q_len)
            total_padding = (tr_factor * q_len - seq_len)
            padding = (total_padding // 2, total_padding - total_padding // 2)
            self.W_P = nn.Sequential(Pad1d(padding), Conv1d(c_in, d_model, kernel_size=tr_factor, padding=0, stride=tr_factor))
            pv(f'temporal resolution modified: {seq_len} --> {q_len} time steps: kernel_size={tr_factor}, stride={tr_factor}, padding={padding}.\n', verbose)
        elif kwargs:
            self.new_q_len = True
            t = torch.rand(1, 1, seq_len)
            q_len = Conv1d(1, 1, **kwargs)(t).shape[-1]
            self.W_P = Conv1d(c_in, d_model, **kwargs) # Eq 2
            pv(f'Conv1d with kwargs={kwargs} applied to input to create input encodings\n', verbose)
        else:
            self.W_P = nn.Linear(c_in, d_model)        # Eq 1: projection of feature vectors onto a d-dim vector space
        self.seq_len = q_len

        # Positional encoding
        self.W_pos = self._positional_encoding(pe, learn_pe, q_len, d_model)

        # Residual dropout
        self.dropout = nn.Dropout(dropout)

        # Encoder
        self.encoder = _TSTEncoder(q_len, d_model, n_heads, d_k=d_k, d_v=d_v, d_ff=d_ff, norm=norm, attn_dropout=attn_dropout, dropout=dropout,
                                   pre_norm=pre_norm, activation=act, res_attention=res_attention, n_layers=n_layers, store_attn=store_attn)
        self.transpose = Transpose(-1, -2, contiguous=True)
        self.key_padding_mask, self.padding_var, self.attn_mask = key_padding_mask, padding_var, attn_mask

    def forward(self, inp) -> Tensor:
        r"""Pass the input through the TST backbone.
        Args:
            inp: input (optionally with padding mask. 1s (meaning padded) in padding mask will be ignored while 0s (non-padded) will be unchanged.)
        Shape:
            There are 3 options:
            1. inp: Tensor containing just time series data [bs x nvars x q_len]
            2. inp: Tensor containing time series data plus a padding feature in the last channel [bs x (nvars + 1) x q_len]
            3. inp: tuple containing a tensor with time series data plus a padding mask per batch ([bs x nvars x q_len] , [bs x q_len] )
        """

        # x and padding mask
        if isinstance(inp, tuple): x, key_padding_mask = inp
        elif self.key_padding_mask == 'auto': x, key_padding_mask = self._key_padding_mask(inp) # automatically identify padding mask
        elif self.key_padding_mask == -1: x, key_padding_mask = inp[:, :-1], inp[:, -1]         # padding mask is the last channel
        else: x, key_padding_mask = inp, None

        # Input encoding
        if self.new_q_len: u = self.W_P(x).transpose(2,1) # Eq 2        # u: [bs x d_model x q_len] transposed to [bs x q_len x d_model]
        else: u = self.W_P(x.transpose(2,1))              # Eq 1        # u: [bs x q_len x nvars] converted to [bs x q_len x d_model]

        # Positional encoding
        u = self.dropout(u + self.W_pos)

        # Encoder
        z = self.encoder(u, key_padding_mask=key_padding_mask, attn_mask=self.attn_mask)    # z: [bs x q_len x d_model]
        z = self.transpose(z)                                                               # z: [bs x d_model x q_len]
        if key_padding_mask is not None:
            z = z * torch.logical_not(key_padding_mask.unsqueeze(1))  # zero-out padding embeddings
        return z

    def _positional_encoding(self, pe, learn_pe, q_len, d_model):
        # Positional encoding
        if pe == None:
            W_pos = torch.empty((q_len, d_model)) # pe = None and learn_pe = False can be used to measure impact of pe
            nn.init.uniform_(W_pos, -0.02, 0.02)
            learn_pe = False
        elif pe == 'zero':
            W_pos = torch.empty((q_len, 1))
            nn.init.uniform_(W_pos, -0.02, 0.02)
        elif pe == 'zeros':
            W_pos = torch.empty((q_len, d_model))
            nn.init.uniform_(W_pos, -0.02, 0.02)
        elif pe == 'normal' or pe == 'gauss':
            W_pos = torch.zeros((q_len, 1))
            torch.nn.init.normal_(W_pos, mean=0.0, std=0.1)
        elif pe == 'uniform':
            W_pos = torch.zeros((q_len, 1))
            nn.init.uniform_(W_pos, a=0.0, b=0.1)
        elif pe == 'lin1d': W_pos = Coord1dPosEncoding(q_len, exponential=False, normalize=True)
        elif pe == 'exp1d': W_pos = Coord1dPosEncoding(q_len, exponential=True, normalize=True)
        elif pe == 'lin2d': W_pos = Coord2dPosEncoding(q_len, d_model, exponential=False, normalize=True)
        elif pe == 'exp2d': W_pos = Coord2dPosEncoding(q_len, d_model, exponential=True, normalize=True)
        elif pe == 'sincos': W_pos = PositionalEncoding(q_len, d_model, normalize=True)
        else: raise ValueError(f"{pe} is not a valid pe (positional encoder. Available types: 'gauss'=='normal', \
            'zeros', 'zero', uniform', 'lin1d', 'exp1d', 'lin2d', 'exp2d', 'sincos', None.)")
        return nn.Parameter(W_pos, requires_grad=learn_pe)

    def _key_padding_mask(self, x):
        if self.padding_var is not None:
            mask = TSMaskTensor(x[:, self.padding_var] == 1)            # key_padding_mask: [bs x q_len]
            return x, mask
        else:
            mask = torch.isnan(x)
            x[mask] = 0
            if mask.any():
                mask = TSMaskTensor((mask.float().mean(1)==1).bool())   # key_padding_mask: [bs x q_len]
                return x, mask
            else:
                return x, None

#|export
class TSTPlus(nn.Sequential):
    """TST (Time Series Transformer) is a Transformer that takes continuous time series as inputs"""
    def __init__(self, c_in:int, c_out:int, seq_len:int, max_seq_len:Optional[int]=512,
                 n_layers:int=3, d_model:int=128, n_heads:int=16, d_k:Optional[int]=None, d_v:Optional[int]=None,
                 d_ff:int=256, norm:str='BatchNorm', attn_dropout:float=0., dropout:float=0., act:str="gelu", key_padding_mask:bool='auto',
                 padding_var:Optional[int]=None, attn_mask:Optional[Tensor]=None, res_attention:bool=True, pre_norm:bool=False, store_attn:bool=False,
                 pe:str='zeros', learn_pe:bool=True, flatten:bool=True, fc_dropout:float=0.,
                 concat_pool:bool=False, bn:bool=False, custom_head:Optional[Callable]=None,
                 y_range:Optional[tuple]=None, verbose:bool=False, **kwargs):
        """
        Args:
            c_in: the number of features (aka variables, dimensions, channels) in the time series dataset.
            c_out: the number of target classes.
            seq_len: number of time steps in the time series.
            max_seq_len: useful to control the temporal resolution in long time series to avoid memory issues. Default=512.
            d_model: total dimension of the model (number of features created by the model). Default: 128 (range(64-512))
            n_heads:  parallel attention heads. Default:16 (range(8-16)).
            d_k: size of the learned linear projection of queries and keys in the MHA. Usual values: 16-512. Default: None -> (d_model/n_heads) = 32.
            d_v: size of the learned linear projection of values in the MHA. Usual values: 16-512. Default: None -> (d_model/n_heads) = 32.
            d_ff: the dimension of the feedforward network model. Default: 512 (range(256-512))
            norm: flag to indicate whether BatchNorm (default) or LayerNorm is used in the encoder layers.
            attn_dropout: dropout applied to the attention scores
            dropout: amount of dropout applied to all linear layers except q,k&v projections in the encoder.
            act: the activation function of intermediate layer, relu or gelu.
            key_padding_mask:   a boolean padding mask will be applied to attention if 'auto' a mask to those steps in a sample where all features are nan.
                                Other options include: True -->tuple (x, key_padding_mask), -1 --> key_padding_mask is the last channel, False: no mask.
            padding_var: (optional) an int indicating the variable that contains the padded steps (0: non-padded, 1: padded).
            attn_mask: a boolean mask will be applied to attention if a tensor of shape [min(seq_len, max_seq_len) x min(seq_len, max_seq_len)] if provided.
            res_attention: if True Residual MultiheadAttention is applied.
            pre_norm: if True normalization will be applied as the first step in the sublayers. Defaults to False
            store_attn: can be used to visualize attention weights. Default: False.
            n_layers: number of layers (or blocks) in the encoder. Default: 3 (range(1-4))
            pe: type of positional encoder.
                Available types (for experimenting): None, 'exp1d', 'lin1d', 'exp2d', 'lin2d', 'sincos', 'gauss' or 'normal',
                'uniform', 'zero', 'zeros' (default, as in the paper).
            learn_pe: learned positional encoder (True, default) or fixed positional encoder.
            flatten: this will flatten the encoder output to be able to apply an mlp type of head (default=False)
            fc_dropout: dropout applied to the final fully connected layer.
            concat_pool: indicates if global adaptive concat pooling will be used instead of global adaptive pooling.
            bn: indicates if batchnorm will be applied to the head.
            custom_head: custom head that will be applied to the network. It must contain all kwargs (pass a partial function)
            y_range: range of possible y values (used in regression tasks).
            kwargs: nn.Conv1d kwargs. If not {}, a nn.Conv1d with those kwargs will be applied to original time series.
        Input shape:
            x: bs (batch size) x nvars (aka features, variables, dimensions, channels) x seq_len (aka time steps)
            attn_mask: q_len x q_len
            As mentioned in the paper, the input must be standardized by_var based on the entire training set.
        """
        # Backbone
        backbone = _TSTBackbone(c_in, seq_len=seq_len, max_seq_len=max_seq_len,
                                n_layers=n_layers, d_model=d_model, n_heads=n_heads, d_k=d_k, d_v=d_v, d_ff=d_ff,
                                attn_dropout=attn_dropout, dropout=dropout, act=act, key_padding_mask=key_padding_mask, padding_var=padding_var,
                                attn_mask=attn_mask, res_attention=res_attention, pre_norm=pre_norm, store_attn=store_attn,
                                pe=pe, learn_pe=learn_pe, verbose=verbose, **kwargs)

        # Head
        self.head_nf = d_model
        self.c_out = c_out
        self.seq_len = backbone.seq_len
        if custom_head is not None:
            if isinstance(custom_head, nn.Module): head = custom_head
            else: head = custom_head(self.head_nf, c_out, seq_len)
        else: head = self.create_head(self.head_nf, c_out, self.seq_len, act=act, flatten=flatten, concat_pool=concat_pool,
                                           fc_dropout=fc_dropout, bn=bn, y_range=y_range)
        super().__init__(OrderedDict([('backbone', backbone), ('head', head)]))


    def create_head(self, nf, c_out, seq_len, flatten=True, concat_pool=False, act="gelu", fc_dropout=0., bn=False, y_range=None):
        layers = [get_act_fn(act)]
        if flatten:
            nf *= seq_len
            layers += [Flatten()]
        else:
            if concat_pool: nf *= 2
            layers = [GACP1d(1) if concat_pool else GAP1d(1)]
        layers += [LinBnDrop(nf, c_out, bn=bn, p=fc_dropout)]
        if y_range: layers += [SigmoidRange(*y_range)]
        return nn.Sequential(*layers)


    def show_pe(self, cmap='viridis', figsize=None):
        plt.figure(figsize=figsize)
        plt.pcolormesh(self.backbone.W_pos.detach().cpu().T, cmap=cmap)
        plt.title('Positional Encoding')
        plt.colorbar()
        plt.show()
        plt.figure(figsize=figsize)
        plt.title('Positional Encoding - value along time axis')
        plt.plot(F.relu(self.backbone.W_pos.data).mean(1).cpu())
        plt.plot(-F.relu(-self.backbone.W_pos.data).mean(1).cpu())
        plt.show()



============================================================

FILE 4/4: log_folder.py
============================================================
Full Path: /home/prod/Desktop/ddos/log_folder.py
Size: 8,644 bytes
Modified: 2025-10-07 14:44:19
------------------------------------------------------------
#!/usr/bin/env python3
"""
Directory Tree and Python File Content Logger

This script creates a comprehensive log of:
1. Complete directory tree structure (like 'tree /f' command)
2. Contents of all Python (.py) files found recursively
3. Saves everything to a single .txt file

Usage:
    python log_project_structure.py [root_directory] [output_file]
    
Example:
    python log_project_structure.py . project_structure.txt
    python log_project_structure.py C:/Users/burak/Desktop/research research_complete.txt
"""

import os
import sys
import argparse
from pathlib import Path
from datetime import datetime

def log_directory_tree(root_path, output_file, skip_dirs: set | None = None):
    """Log the complete directory tree structure."""
    output_file.write("="*80 + "\n")
    output_file.write("DIRECTORY TREE STRUCTURE\n")
    output_file.write("="*80 + "\n")
    output_file.write(f"Root Directory: {root_path}\n")
    output_file.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
    if skip_dirs is None:
        skip_dirs = set()

    def write_tree(path, prefix="", is_last=True):
        """Recursively write tree structure."""
        try:
            items = sorted(path.iterdir())
            folders = [item for item in items if item.is_dir() and not item.name.startswith('.') and item.name not in skip_dirs]
            files = [item for item in items if item.is_file() and not item.name.startswith('.')]
            
            # Write folders first
            for i, folder in enumerate(folders):
                is_last_folder = (i == len(folders) - 1) and len(files) == 0
                connector = "└── " if is_last_folder else "├── "
                output_file.write(f"{prefix}{connector}{folder.name}/\n")
                
                extension = "    " if is_last_folder else "│   "
                write_tree(folder, prefix + extension, is_last_folder)
            
            # Write files
            for i, file in enumerate(files):
                is_last_file = (i == len(files) - 1)
                connector = "└── " if is_last_file else "├── "
                file_size = file.stat().st_size if file.exists() else 0
                output_file.write(f"{prefix}{connector}{file.name} ({file_size:,} bytes)\n")
                
        except PermissionError:
            output_file.write(f"{prefix}├── [Permission Denied]\n")
        except Exception as e:
            output_file.write(f"{prefix}├── [Error: {e}]\n")
    
    write_tree(Path(root_path))
    output_file.write("\n\n")

def log_python_files(root_path, output_file):
    """Log contents of all Python files found recursively."""
    output_file.write("="*80 + "\n")
    output_file.write("PYTHON FILE CONTENTS\n")
    output_file.write("="*80 + "\n\n")
    
    python_files = []
    
    # Find all Python files
    for root, dirs, files in os.walk(root_path):
        # Skip hidden directories
        # The caller may pass a set of directory NAMES to skip (e.g. 'tests')
        dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__' and d not in SKIP_DIRS]
        
        for file in files:
            if file.endswith('.py') and not file.startswith('.'):
                python_files.append(os.path.join(root, file))
    
    python_files.sort()  # Sort for consistent output
    
    if not python_files:
        output_file.write("No Python files found.\n\n")
        return
    
    output_file.write(f"Found {len(python_files)} Python files:\n")
    for i, py_file in enumerate(python_files, 1):
        rel_path = os.path.relpath(py_file, root_path)
        output_file.write(f"  {i:2d}. {rel_path}\n")
    output_file.write("\n" + "-"*80 + "\n\n")
    
    # Log contents of each Python file
    for i, py_file in enumerate(python_files, 1):
        rel_path = os.path.relpath(py_file, root_path)
        
        output_file.write(f"FILE {i}/{len(python_files)}: {rel_path}\n")
        output_file.write("="*60 + "\n")
        output_file.write(f"Full Path: {py_file}\n")
        
        try:
            file_stat = os.stat(py_file)
            file_size = file_stat.st_size
            mod_time = datetime.fromtimestamp(file_stat.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
            output_file.write(f"Size: {file_size:,} bytes\n")
            output_file.write(f"Modified: {mod_time}\n")
        except Exception as e:
            output_file.write(f"Error getting file stats: {e}\n")
        
        output_file.write("-"*60 + "\n")
        
        try:
            with open(py_file, 'r', encoding='utf-8', errors='replace') as f:
                content = f.read()
                if content.strip():
                    output_file.write(content)
                    if not content.endswith('\n'):
                        output_file.write('\n')
                else:
                    output_file.write("[Empty file]\n")
        except Exception as e:
            output_file.write(f"[Error reading file: {e}]\n")
        
        output_file.write("\n" + "="*60 + "\n\n")

def main():
    """Main function."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(
        description="Log directory tree and all Python files. Optionally skip named folders (by name) e.g. 'tests,benchmarks'."
    )
    parser.add_argument("root", nargs="?", default=".", help="Root directory to analyze")
    parser.add_argument("output", nargs="?", help="Output filename (optional)")
    parser.add_argument(
        "-s",
        "--skip",
        action="append",
        help=("Folder name to skip. Can be used multiple times or as a comma-separated list. "
              "Example: -s tests -s docs or -s tests,docs"),
    )

    args = parser.parse_args()

    root_directory = args.root
    if args.output:
        output_filename = args.output
    else:
        output_filename = f"project_structure_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

    # Build skip set (normalize to simple folder names)
    skip_dirs = set()
    if args.skip:
        for entry in args.skip:
            if not entry:
                continue
            for part in entry.split(','):
                name = part.strip()
                if not name:
                    continue
                # normalize possible paths to just the final component
                try:
                    pname = Path(name).name
                except Exception:
                    pname = name
                skip_dirs.add(pname)

    # Never allow skipping the required 'core' directory; remove it if present and warn
    if 'core' in skip_dirs:
        print("Note: 'core' is required and cannot be skipped; ignoring 'core' in --skip list.")
        skip_dirs.discard('core')

    # Make skip set available to module-level walker via global used below
    global SKIP_DIRS
    SKIP_DIRS = skip_dirs

    if SKIP_DIRS:
        print(f"Skipping directories by name: {', '.join(sorted(SKIP_DIRS))}")
    
    # Resolve paths
    root_path = Path(root_directory).resolve()
    output_path = Path(output_filename).resolve()
    
    if not root_path.exists():
        print(f"Error: Root directory '{root_path}' does not exist!")
        sys.exit(1)
    
    if not root_path.is_dir():
        print(f"Error: '{root_path}' is not a directory!")
        sys.exit(1)
    
    print(f"Analyzing directory: {root_path}")
    print(f"Output file: {output_path}")
    print("Processing...")
    
    try:
        with open(output_path, 'w', encoding='utf-8') as output_file:
            # Write header
            output_file.write("PROJECT STRUCTURE AND PYTHON FILES LOG\n")
            output_file.write("="*80 + "\n")
            output_file.write(f"Root Directory: {root_path}\n")
            output_file.write(f"Output File: {output_path}\n")
            output_file.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            output_file.write("="*80 + "\n\n")
            
            # Log directory tree
            log_directory_tree(root_path, output_file)
            
            # Log Python file contents
            log_python_files(root_path, output_file)
            
            # Write footer
            output_file.write("="*80 + "\n")
            output_file.write("END OF LOG\n")
            output_file.write("="*80 + "\n")
    
    except Exception as e:
        print(f"Error writing to output file: {e}")
        sys.exit(1)
    
    print(f"✅ Successfully created: {output_path}")
    print(f"📁 Log contains directory tree + all Python file contents")

if __name__ == "__main__":
    main()

============================================================

================================================================================
END OF LOG
================================================================================
