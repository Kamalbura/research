# Create a single, consolidated project context file the user can give to their GitHub Copilot agent.
# It captures architecture, directory layout, crypto invariants, ports, topics, RL, DDoS, testing,
# and strict anti-hallucination guardrails for the agent.

context = r"""
PROJECT: Quantum‑Safe UAV C2 (Drone ⇄ GCS) — PQC Tunnel + DDoS Shield + RL Policy

GOAL (what “done” means)
- A reproducible, quantum‑safe command/telemetry tunnel between UAV (Raspberry Pi 4B + Pixhawk 2.4.8) and GCS (PC).
- Suites covering NIST Levels L1/L3/L5 using ML‑KEM (Kyber) for KEM and ML‑DSA (Dilithium) / Falcon / SPHINCS+ for signature.
- Authenticated handshake; AES‑GCM data plane with AAD‑bound headers, 12‑byte counter nonces, replay protection, safe rekey.
- Two‑stage DDoS detection (Stage‑1 XGBoost → Stage‑2 TST) that can rate‑limit/drop low‑priority telemetry without affecting commands.
- Lightweight RL (contextual bandit) to select suites and mitigations under constraints (never drop below mission’s required security).
- Benchmarks + figures (latency p50/p95/p99, handshake ms/bytes, CPU%, energy/packet, DDoS ROC/PR, policy timeline).

HARDWARE / SOFTWARE
- Drone: Raspberry Pi 4B (64‑bit OS), Pixhawk 2.4.8 via USB, Wi‑Fi link to router.
- GCS: Linux/Windows PC (Python 3.10+; Conda env “gcs-env” ok).
- Python: liboqs via oqs-python, pyca/cryptography, pymavlink+MAVProxy, paho‑mqtt, numpy/pandas, psutil, scapy, xgboost, torch (for TST).

REPO LAYOUT (single repo; both sides share core)
pqc-drone-gcs/
├─ docs/
│  ├─ OVERVIEW.md, PORTS_AND_FLOW.md, SECURITY_DESIGN.md, NIST_LEVELS.md, MEASUREMENT_METHODS.md
├─ core/                             # SINGLE source of truth for crypto & transport
│  ├─ run_proxy.py                   # CLI: --role {gcs,drone} --suite <id> --bind ... --peer ...
│  ├─ async_proxy.py                 # UDP loops, backpressure, thread/async wrappers
│  ├─ handshake.py                   # KEM + signed transcript + HKDF derivation
│  ├─ aead.py                        # AES‑GCM pack/decrypt with header AAD, replay window, epochs
│  ├─ suites.py                      # registry: suite_id → {kem, sig, aead, kdf, params, nist_level}
│  ├─ config.py                      # ports, IPs, topics; env overrides; shared by both sides
│  ├─ logging_utils.py               # structured logs (JSON), metrics hooks
│  └─ utils_netem.py                 # helpers for controlled impairments in tests
├─ drone/
│  ├─ wrappers/                      # thin launchers (one file per “named suite”)
│  │  ├─ drone_kyber_512.py ... drone_sphincs_* .py (all variants call core/run_proxy.py)
│  └─ scripts/ start_suite.sh, env_check.py
├─ gcs/
│  ├─ wrappers/ (mirrors drone)      # gcs_kyber_512.py ... gcs_sphincs_*.py
│  └─ scripts/ start_suite.sh, env_check.py
├─ ddos/
│  ├─ stage1_xgb.py                  # features + XGBoost binary loading/inference
│  ├─ stage2_tst.py                  # PyTorch TST confirmatory model
│  ├─ features.py, datasets/README.md, train/*.ipynb (optional offline)
│  └─ run_ddos_daemon.py             # publishes /ddos JSON (scores, state) via MQTT
├─ rl/
│  ├─ linucb.py                      # contextual bandit
│  ├─ agent_runtime.py               # observations → action → safe switch via MQTT
│  └─ schema.py                      # JSON schema for /health and /ddos messages
├─ tools/
│  ├─ bench_cli.py, power_hooks.py, wireshark/pqc_tunnel.lua
├─ tests/
│  ├─ test_handshake.py, test_aead_framing.py, test_replay_window.py, test_rekey_epoch.py, test_loss_dup_oom.py
├─ benchmarks/ matrix.yaml, run_matrix.py, results/*.csv
├─ requirements.txt, environment.yml, README.md, LICENSE

CONFIG (core/config.py)
- This file is the single source of truth for IPs, ports, MQTT topics, and suite IDs.
- Example defaults (override with env vars or CLI):
  GCS_IP="192.168.1.10"; DRONE_IP="192.168.1.20"
  TCP_HANDSHAKE_PORT=5800                         # KEM+signature handshake over TCP
  UDP_DRONE_RX=5810; UDP_GCS_RX=5811              # encrypted data plane (UDP)
  UDP_FC_IN=14550; UDP_FC_OUT=14551               # MAVLink to/from flight controller
  MQTT_BROKER="192.168.1.5"; MQTT_PORT=1883
  TOPIC_HEALTH="/health"; TOPIC_DDOS="/ddos"
  TOPIC_ALGO_DESIRED="/algo/desired"; TOPIC_ALGO_ACK="/algo/ack"
  TOPIC_POLICY_TEL_RATE="/policy/telemetry_downsample"
  TOPIC_POLICY_LIMIT="/policy/ingress_limit"

CRYPTO INVARIANTS (NON‑NEGOTIABLE)
1) Handshake must be authenticated: GCS signs transcript T = (session_id || kem_name || gcs_pub) with selected signature (Dilithium/Falcon/SPHINCS+). Drone verifies against provisioned GCS signature public key.
2) KEM → shared secret → HKDF‑SHA256 → derive K_send, K_recv, nonce_seed; never use raw KEM secret directly.
3) AES‑GCM with deterministic 96‑bit counter nonces (per direction). Never reuse nonces.
4) Per‑packet header is AAD (authenticated, not encrypted):
   version(1) | kem_id(1) | kem_param(1) | sig_id(1) | sig_param(1) | session_id(8) | seq(8) | epoch(1)
5) Sliding replay window (e.g., size 1024) per direction; drop duplicates/old.
6) Rekey periodically (by time or packets); bump epoch; safe parallel cutover (new session established before flip).
7) Minimum NIST level enforced from mission profile; never downgrade below it.

SUITES (suites.py / YAML)
- Provide these named suites (at least):
  cs-kyber512-aesgcm-dilithium2   (L1)
  cs-kyber768-aesgcm-dilithium3   (L3)  ← default
  cs-kyber1024-aesgcm-dilithium5  (L5)
  cs-kyber768-aesgcm-falcon512    (L3, smaller signatures)
  cs-kyber768-chacha20-sphincs128f (L3, conservative, larger signatures)
- Each suite defines: kem_name, sig_name, aead="AES-256-GCM", hkdf="HKDF-SHA256", nist_level, rekey_policy.

DATA PLANE (core/aead.py)
- Sender packs header (AAD), uses seq (uint64) as nonce counter → 12‑byte big‑endian IV.
- Receiver verifies tag with header as AAD; checks replay window; returns plaintext.
- Expose metrics (p50/p95 encrypt/decrypt μs, drops_s, rtt, loss) via /health.

DDoS (ddos/)
- Stage‑1 XGBoost: cheap features computed from pre‑decrypt queues: pps, burstiness, unique 5‑tuples, SYN/UDP ratios, etc. Emits score ∈ [0,1].
- Stage‑2 TST (PyTorch): run only when Stage‑1 score exceeds threshold; confirm anomaly with short time window. Emits score ∈ [0,1].
- Combiner → ddos_state ∈ {0 ok, 1 suspect, 2 attack}; publish JSON to /ddos.
- Mitigations are executed by proxy when instructed: ingress limiter (off/2kpps/1kpps); telemetry downsample (1.0/0.7/0.4). Never throttle command path.

RL (rl/)
- Observations (normalized): cpu_pct, loss_pct, aead_p95_us, rtt_ms, xgb_score, tst_score, mission.priority, mission.min_sec.
- Actions: {suite L1/L3/L5 or L3‑smallSig/L3‑conservative, rekey_now, telemetry_downsample {1.0,0.7,0.4}, ingress_limit {off,2k,1k}}.
- Reward r = 2*SLA_ok − 1*CPU_norm − 0.5*loss − 0.3*p95 + 0.2*SecScore − 0.3*ddos_state − 0.1*rekey_cost.
- Safety shield: enforce mission.min_sec; freeze suite under ddos_state≥1; prioritize command channel.

TESTS (must pass before “done”)
- test_handshake: MitM swap fails; wrong signature fails; derive keys match (K_send/recv) on both sides.
- test_aead_framing: tampered header or nonce reuse → decryption fails.
- test_replay_window: duplicate/old seq dropped.
- test_rekey_epoch: epoch increments; counters reset; parallel cutover success.
- test_loss_dup_oom: tolerates 10% loss, out‑of‑order within window, and backpressure without deadlocks.

BENCHMARKS (benchmarks/)
- Report latency p50/p95/p99 per payload size (64/256/512/1024B), handshake ms/bytes, CPU%, mJ/packet, DDoS ROC/PR, RL reward/timeline.
- Store CSVs in benchmarks/results/ and generate all figures from CSVs.

RUN BOOK (quick start)
1) Install oqs-python + pyca/cryptography in both envs; verify core/scripts/env_check.py passes.
2) Start ddos/run_ddos_daemon.py on both sides (publishes /ddos).
3) Launch GCS proxy: python core/run_proxy.py --role gcs --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5811 --peer DRONE_IP:5810
4) Launch Drone proxy: python core/run_proxy.py --role drone --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5810 --peer GCS_IP:5811
5) Connect MAVProxy/pymavlink to local plaintext ports that the proxy exposes for the FC.
6) Optional: start rl/agent_runtime.py (GCS side) to manage suite and mitigations via MQTT.

STYLE / CONTRIBUTION RULES FOR THE AI AGENT (STRICT)
- DO NOT fabricate code, paths, or results. If unknown, say “UNKNOWN: needs human input.”
- NO placeholders that pretend to be implemented. If a function is stubbed, it MUST raise NotImplementedError.
- Every new module must include a minimal self‑test or unit test.
- Keep all crypto in core/*.py; wrappers in drone/gcs/wrappers must not re‑implement crypto.
- All wire changes MUST update docs/PORTS_AND_FLOW.md and tests.
- NEVER weaken crypto for convenience (e.g., random nonces, skipping AAD, skipping signature).
- Always use suites.py registry for algorithm names; no hardcoded strings elsewhere.
- External references (papers/repos) must be added to docs/REFERENCES.md when first used.

DEFINITION OF DONE (DOD)
- All tests pass; end‑to‑end encrypt→decrypt loop verified; replay & tamper tests pass.
- Benchmarks run across the suite matrix and emit CSVs; figures regenerate.
- README shows exact commands to reproduce the demo.
- No TODO/FIXME strings in production code; stubs are isolated behind feature flags.

SECURITY NOTES
- Provision the GCS signature public key on the drone out‑of‑band.
- Log only metadata (session_id, suite, seq ranges, timings), never secrets or raw plaintexts.
- Ensure time‑constant comparisons where needed (e.g., tags).

LICENSE & ATTRIBUTION
- Respect upstream licenses for oqs‑python, cryptography, MAVLink, XGBoost, PyTorch, etc. Document in LICENSE/NOTICE.
"""
with open("/mnt/data/PROJECT_CONTEXT.txt", "w", encoding="utf-8") as f:
    f.write(context)

"/mnt/data/PROJECT_CONTEXT.txt"
--------------------------------------------------------------------------------------


Totally doable. You just need **thin, no-arg wrapper scripts** that hard-code the role + suite they should run, and call a single shared runner. Then you start them like:

```
python drone/drone_kyber_768.py
python gcs/gcs_dilithium3.py
```

No flags, no CLI parsing.

Below is a clean pattern + ready-to-paste code (runner + two example wrappers) **and** a small generator that writes all wrapper files for you.

---

# 1) Common runner (one place to keep the logic)

Create `core/runner.py`:

```python
# core/runner.py
import sys, time
from core.config import CONFIG
from core.suites import get_suite
from core.async_proxy import run_proxy  # your existing main loop (UDP+TCP+HKDF+AESGCM)

def start(role: str, suite_id: str):
    """
    No-args entrypoint used by wrappers.
    role: "drone" or "gcs"
    suite_id: e.g., "cs-kyber768-aesgcm-dilithium3"
    """
    suite = get_suite(suite_id)
    cfg = CONFIG  # central IPs/ports/mqtt etc.
    # Optional: allow env overrides without CLI (keeps 'no args' contract)
    # e.g., if os.environ.get("GCS_IP"): cfg["GCS_HOST"] = os.environ["GCS_IP"]

    print(f"[boot] role={role} suite={suite_id}")
    try:
        run_proxy(role=role, suite=suite, cfg=cfg)  # blocks forever
    except KeyboardInterrupt:
        print("\n[stop] shutting down cleanly")
```

> `run_proxy` is your existing proxy loop; if you named it differently, just adapt that import.

---

# 2) Two tiny wrapper examples (no CLI)

### `drone/drone_kyber_768.py`

```python
# drone/drone_kyber_768.py
from core.runner import start

ROLE     = "drone"
SUITE_ID = "cs-kyber768-aesgcm-dilithium3"   # NIST L3 default

if __name__ == "__main__":
    start(ROLE, SUITE_ID)
```

### `gcs/gcs_falcon512.py`

```python
# gcs/gcs_falcon512.py
from core.runner import start

ROLE     = "gcs"
SUITE_ID = "cs-kyber768-aesgcm-falcon512"    # compact-sig variant

if __name__ == "__main__":
    start(ROLE, SUITE_ID)
```

That’s it. Run them directly; they never read argv.

---

# 3) Autogenerate *all* wrappers once (optional)

If you don’t want to hand-write 12+ files, add `tools/make_wrappers.py` and run it **once**:

```python
# tools/make_wrappers.py
from pathlib import Path

WRAPPERS = {
  "drone": {
    "drone_kyber_512.py":        "cs-kyber512-aesgcm-dilithium2",
    "drone_kyber_768.py":        "cs-kyber768-aesgcm-dilithium3",
    "drone_kyber_1024.py":       "cs-kyber1024-aesgcm-dilithium5",
    "drone_dilithium2.py":       "cs-kyber512-aesgcm-dilithium2",
    "drone_dilithium3.py":       "cs-kyber768-aesgcm-dilithium3",
    "drone_dilithium5.py":       "cs-kyber1024-aesgcm-dilithium5",
    "drone_falcon512.py":        "cs-kyber768-aesgcm-falcon512",
    "drone_falcon1024.py":       "cs-kyber1024-aesgcm-falcon1024",
    "drone_sphincs_sha2_128f.py":"cs-kyber512-aesgcm-sphincs128f_sha2",
    "drone_sphincs_sha2_256f.py":"cs-kyber1024-aesgcm-sphincs256f_sha2",
    "drone_sphincs_shake_128f.py":"cs-kyber512-aesgcm-sphincs128f_shake",
    "drone_sphincs_shake_256f.py":"cs-kyber1024-aesgcm-sphincs256f_shake",
  },
  "gcs": {
    "gcs_kyber_512.py":          "cs-kyber512-aesgcm-dilithium2",
    "gcs_kyber_768.py":          "cs-kyber768-aesgcm-dilithium3",
    "gcs_kyber_1024.py":         "cs-kyber1024-aesgcm-dilithium5",
    "gcs_dilithium2.py":         "cs-kyber512-aesgcm-dilithium2",
    "gcs_dilithium3.py":         "cs-kyber768-aesgcm-dilithium3",
    "gcs_dilithium5.py":         "cs-kyber1024-aesgcm-dilithium5",
    "gcs_falcon512.py":          "cs-kyber768-aesgcm-falcon512",
    "gcs_falcon1024.py":         "cs-kyber1024-aesgcm-falcon1024",
    "gcs_sphincs_sha2_128f.py":  "cs-kyber512-aesgcm-sphincs128f_sha2",
    "gcs_sphincs_sha2_256f.py":  "cs-kyber1024-aesgcm-sphincs256f_sha2",
    "gcs_sphincs_shake_128f.py": "cs-kyber512-aesgcm-sphincs128f_shake",
    "gcs_sphincs_shake_256f.py": "cs-kyber1024-aesgcm-sphincs256f_shake",
  }
}

TEMPLATE = """# {path}
from core.runner import start
ROLE = "{role}"
SUITE_ID = "{suite}"
if __name__ == "__main__":
    start(ROLE, SUITE_ID)
"""

def write_wrappers(root: Path, role: str, mapping: dict):
    d = root / role
    d.mkdir(parents=True, exist_ok=True)
    for fname, suite in mapping.items():
        path = d / fname
        path.write_text(TEMPLATE.format(path=path, role=role, suite=suite))
        print("wrote", path)

if __name__ == "__main__":
    repo = Path(__file__).resolve().parents[1]
    write_wrappers(repo, "drone", WRAPPERS["drone"])
    write_wrappers(repo, "gcs",   WRAPPERS["gcs"])
```

Run:

```
python tools/make_wrappers.py
```

Now you have every script, and you’ll **never** pass args again.

---

# 4) One place for ports/IPs/topics (no args, just import)

Your wrappers and runner pull from `core/config.py`:

```python
# core/config.py
CONFIG = dict(
  # roles
  DRONE_HOST="10.42.0.73",
  GCS_HOST="10.42.0.1",

  # TCP handshake
  TCP_HANDSHAKE_PORT=5800,

  # UDP data-plane
  UDP_GCS_RX_PORT=5078,         # where GCS app expects plaintext
  UDP_GCS_TX_PORT=6000,         # where GCS app sends commands
  UDP_DRONE_IN_PORT=14550,      # where FC/MAVProxy listens
  UDP_DRONE_OUT_PORT=5002,      # toward MAVProxy ingress

  # MQTT (optional control-plane)
  MQTT_BROKER="10.42.0.1",
  MQTT_PORT=8883,
  MQTT_TOPICS=dict(
    HEALTH="/health",
    DDoS="/ddos",
    DESIRED="/algo/desired",
    ACK="/algo/ack",
  ),

  # Rekey policy etc.
  REKEY_SECONDS=600,
  REPLAY_WINDOW=1024,
  LOG_DIR="logs",
)
```

> You can still override via environment variables if you ever need to, but you never *have* to pass a flag.

---

# 5) Suites registry (strings only, no CLI)

Map suite IDs once in `core/suites.py`:

```python
# core/suites.py
SUITES = {
  "cs-kyber512-aesgcm-dilithium2":  dict(kem="ML-KEM-512",  sig="ML-DSA-44",  aead="AES-256-GCM"),
  "cs-kyber768-aesgcm-dilithium3":  dict(kem="ML-KEM-768",  sig="ML-DSA-65",  aead="AES-256-GCM"),
  "cs-kyber1024-aesgcm-dilithium5": dict(kem="ML-KEM-1024", sig="ML-DSA-87",  aead="AES-256-GCM"),
  "cs-kyber768-aesgcm-falcon512":   dict(kem="ML-KEM-768",  sig="Falcon-512", aead="AES-256-GCM"),
  "cs-kyber1024-aesgcm-falcon1024": dict(kem="ML-KEM-1024", sig="Falcon-1024",aead="AES-256-GCM"),
  "cs-kyber512-aesgcm-sphincs128f_sha2":  dict(kem="ML-KEM-512",  sig="SLH-DSA-SHA2-128f",  aead="AES-256-GCM"),
  "cs-kyber1024-aesgcm-sphincs256f_sha2": dict(kem="ML-KEM-1024", sig="SLH-DSA-SHA2-256f",  aead="AES-256-GCM"),
  "cs-kyber512-aesgcm-sphincs128f_shake": dict(kem="ML-KEM-512",  sig="SLH-DSA-SHAKE-128f", aead="AES-256-GCM"),
  "cs-kyber1024-aesgcm-sphincs256f_shake":dict(kem="ML-KEM-1024", sig="SLH-DSA-SHAKE-256f", aead="AES-256-GCM"),
}

def get_suite(suite_id: str) -> dict:
    if suite_id not in SUITES:
        raise KeyError(f"Unknown suite_id {suite_id}")
    return SUITES[suite_id]
```

---

# 6) Optional: systemd services (still no args)

Example for drone side `drone-kyber768.service`:

```
[Unit]
Description=Drone PQC Proxy (Kyber768+Dilithium3)
After=network-online.target

[Service]
User=pi
WorkingDirectory=/home/pi/pqc-drone-gcs
ExecStart=/usr/bin/python3 /home/pi/pqc-drone-gcs/drone/drone_kyber_768.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

Enable with:

```
sudo systemctl enable --now drone-kyber768.service
```

---

## TL;DR

* Put **all** logic in `core/runner.start(role, suite_id)`.
* Create **one wrapper per file** that sets two constants and calls `start(...)`.
* (Optional) Use the generator once to create all 12+ wrappers.
* From then on, it’s always: **“run the file, no arguments.”** ✅

If you want, I can also spit out the wrapper generator adapted to your exact repo path and write all 24 scripts (drone + gcs) using your current suite naming.

-------------------------------------------------------------------------
Done. Grab your project context here:
[Download PROJECT\_CONTEXT.txt](sandbox:/mnt/data/PROJECT_CONTEXT.txt)

Want me to also generate the per-topic TXT files (e.g., `post_quantum_crypto.txt`, `mqtt_mtls.txt`, `ports_and_flow.txt`) in the same folder so you can drop them into the repo?
Done. Grab your project context here:
[Download PROJECT\_CONTEXT.txt](sandbox:/mnt/data/PROJECT_CONTEXT.txt)

Want me to also generate the per-topic TXT files (e.g., `post_quantum_crypto.txt`, `mqtt_mtls.txt`, `ports_and_flow.txt`) in the same folder so you can drop them into the repo?
# Re-create the context file after kernel reset.
context = r"""
PROJECT: Quantum-Safe UAV C2 (Drone ⇄ GCS) — PQC Tunnel + DDoS Shield + RL Policy

GOAL (what “done” means)
- A reproducible, quantum-safe command/telemetry tunnel between UAV (Raspberry Pi 4B + Pixhawk 2.4.8) and GCS (PC).
- Suites covering NIST Levels L1/L3/L5 using ML-KEM (Kyber) for KEM and ML-DSA (Dilithium) / Falcon / SPHINCS+ for signature.
- Authenticated handshake; AES-GCM data plane with AAD-bound headers, 12-byte counter nonces, replay protection, safe rekey.
- Two-stage DDoS detection (Stage-1 XGBoost → Stage-2 TST) that can rate-limit/drop low-priority telemetry without affecting commands.
- Lightweight RL (contextual bandit) to select suites and mitigations under constraints (never drop below mission’s required security).
- Benchmarks + figures (latency p50/p95/p99, handshake ms/bytes, CPU%, energy/packet, DDoS ROC/PR, policy timeline).

HARDWARE / SOFTWARE
- Drone: Raspberry Pi 4B (64-bit OS), Pixhawk 2.4.8 via USB, Wi-Fi link to router.
- GCS: Linux/Windows PC (Python 3.10+; Conda env “gcs-env” ok).
- Python: liboqs via oqs-python, pyca/cryptography, pymavlink+MAVProxy, paho-mqtt, numpy/pandas, psutil, scapy, xgboost, torch (for TST).

REPO LAYOUT (single repo; both sides share core)
pqc-drone-gcs/
├─ docs/
│  ├─ OVERVIEW.md, PORTS_AND_FLOW.md, SECURITY_DESIGN.md, NIST_LEVELS.md, MEASUREMENT_METHODS.md
├─ core/                             # SINGLE source of truth for crypto & transport
│  ├─ run_proxy.py                   # CLI: --role {gcs,drone} --suite <id> --bind ... --peer ...
│  ├─ async_proxy.py                 # UDP loops, backpressure, thread/async wrappers
│  ├─ handshake.py                   # KEM + signed transcript + HKDF derivation
│  ├─ aead.py                        # AES-GCM pack/decrypt with header AAD, replay window, epochs
│  ├─ suites.py                      # registry: suite_id → {kem, sig, aead, kdf, params, nist_level}
│  ├─ config.py                      # ports, IPs, topics; env overrides; shared by both sides
│  ├─ logging_utils.py               # structured logs (JSON), metrics hooks
│  └─ utils_netem.py                 # helpers for controlled impairments in tests
├─ drone/
│  ├─ wrappers/                      # thin launchers (one file per “named suite”)
│  │  ├─ drone_kyber_512.py ... drone_sphincs_* .py (all variants call core/run_proxy.py)
│  └─ scripts/ start_suite.sh, env_check.py
├─ gcs/
│  ├─ wrappers/ (mirrors drone)      # gcs_kyber_512.py ... gcs_sphincs_*.py
│  └─ scripts/ start_suite.sh, env_check.py
├─ ddos/
│  ├─ stage1_xgb.py                  # features + XGBoost binary loading/inference
│  ├─ stage2_tst.py                  # PyTorch TST confirmatory model
│  ├─ features.py, datasets/README.md, train/*.ipynb (optional offline)
│  └─ run_ddos_daemon.py             # publishes /ddos JSON (scores, state) via MQTT
├─ rl/
│  ├─ linucb.py                      # contextual bandit
│  ├─ agent_runtime.py               # observations → action → safe switch via MQTT
│  └─ schema.py                      # JSON schema for /health and /ddos messages
├─ tools/
│  ├─ bench_cli.py, power_hooks.py, wireshark/pqc_tunnel.lua
├─ tests/
│  ├─ test_handshake.py, test_aead_framing.py, test_replay_window.py, test_rekey_epoch.py, test_loss_dup_oom.py
├─ benchmarks/ matrix.yaml, run_matrix.py, results/*.csv
├─ requirements.txt, environment.yml, README.md, LICENSE

CONFIG (core/config.py)
- This file is the single source of truth for IPs, ports, MQTT topics, and suite IDs.
- Example defaults (override with env vars or CLI):
  GCS_IP="192.168.1.10"; DRONE_IP="192.168.1.20"
  TCP_HANDSHAKE_PORT=5800                         # KEM+signature handshake over TCP
  UDP_DRONE_RX=5810; UDP_GCS_RX=5811              # encrypted data plane (UDP)
  UDP_FC_IN=14550; UDP_FC_OUT=14551               # MAVLink to/from flight controller
  MQTT_BROKER="192.168.1.5"; MQTT_PORT=1883
  TOPIC_HEALTH="/health"; TOPIC_DDOS="/ddos"
  TOPIC_ALGO_DESIRED="/algo/desired"; TOPIC_ALGO_ACK="/algo/ack"
  TOPIC_POLICY_TEL_RATE="/policy/telemetry_downsample"
  TOPIC_POLICY_LIMIT="/policy/ingress_limit"

CRYPTO INVARIANTS (NON-NEGOTIABLE)
1) Handshake must be authenticated: GCS signs transcript T = (session_id || kem_name || gcs_pub) with selected signature (Dilithium/Falcon/SPHINCS+). Drone verifies against provisioned GCS signature public key.
2) KEM → shared secret → HKDF-SHA256 → derive K_send, K_recv, nonce_seed; never use raw KEM secret directly.
3) AES-GCM with deterministic 96-bit counter nonces (per direction). Never reuse nonces.
4) Per-packet header is AAD (authenticated, not encrypted):
   version(1) | kem_id(1) | kem_param(1) | sig_id(1) | sig_param(1) | session_id(8) | seq(8) | epoch(1)
5) Sliding replay window (e.g., size 1024) per direction; drop duplicates/old.
6) Rekey periodically (by time or packets); bump epoch; safe parallel cutover (new session established before flip).
7) Minimum NIST level enforced from mission profile; never downgrade below it.

SUITES (suites.py / YAML)
- Provide these named suites (at least):
  cs-kyber512-aesgcm-dilithium2   (L1)
  cs-kyber768-aesgcm-dilithium3   (L3)  ← default
  cs-kyber1024-aesgcm-dilithium5  (L5)
  cs-kyber768-aesgcm-falcon512    (L3, smaller signatures)
  cs-kyber768-chacha20-sphincs128f (L3, conservative, larger signatures)
- Each suite defines: kem_name, sig_name, aead="AES-256-GCM", hkdf="HKDF-SHA256", nist_level, rekey_policy.

DATA PLANE (core/aead.py)
- Sender packs header (AAD), uses seq (uint64) as nonce counter → 12-byte big-endian IV.
- Receiver verifies tag with header as AAD; checks replay window; returns plaintext.
- Expose metrics (p50/p95 encrypt/decrypt μs, drops_s, rtt, loss) via /health.

DDoS (ddos/)
- Stage-1 XGBoost: cheap features computed from pre-decrypt queues: pps, burstiness, unique 5-tuples, SYN/UDP ratios, etc. Emits score ∈ [0,1].
- Stage-2 TST (PyTorch): run only when Stage-1 score exceeds threshold; confirm anomaly with short time window. Emits score ∈ [0,1].
- Combiner → ddos_state ∈ {0 ok, 1 suspect, 2 attack}; publish JSON to /ddos.
- Mitigations are executed by proxy when instructed: ingress limiter (off/2kpps/1kpps); telemetry downsample (1.0/0.7/0.4). Never throttle command path.

RL (rl/)
- Observations (normalized): cpu_pct, loss_pct, aead_p95_us, rtt_ms, xgb_score, tst_score, mission.priority, mission.min_sec.
- Actions: {suite L1/L3/L5 or L3-smallSig/L3-conservative, rekey_now, telemetry_downsample {1.0,0.7,0.4}, ingress_limit {off,2k,1k}}.
- Reward r = 2*SLA_ok − 1*CPU_norm − 0.5*loss − 0.3*p95 + 0.2*SecScore − 0.3*ddos_state − 0.1*rekey_cost.
- Safety shield: enforce mission.min_sec; freeze suite under ddos_state≥1; prioritize command channel.

TESTS (must pass before “done”)
- test_handshake: MitM swap fails; wrong signature fails; derive keys match (K_send/recv) on both sides.
- test_aead_framing: tampered header or nonce reuse → decryption fails.
- test_replay_window: duplicate/old seq dropped.
- test_rekey_epoch: epoch increments; counters reset; parallel cutover success.
- test_loss_dup_oom: tolerates 10% loss, out-of-order within window, and backpressure without deadlocks.

BENCHMARKS (benchmarks/)
- Report latency p50/p95/p99 per payload size (64/256/512/1024B), handshake ms/bytes, CPU%, mJ/packet, DDoS ROC/PR, RL reward/timeline).
- Store CSVs in benchmarks/results/ and generate all figures from CSVs.

RUN BOOK (quick start)
1) Install oqs-python + pyca/cryptography in both envs; verify core/scripts/env_check.py passes.
2) Start ddos/run_ddos_daemon.py on both sides (publishes /ddos).
3) Launch GCS proxy: python core/run_proxy.py --role gcs --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5811 --peer DRONE_IP:5810
4) Launch Drone proxy: python core/run_proxy.py --role drone --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5810 --peer GCS_IP:5811
5) Connect MAVProxy/pymavlink to local plaintext ports that the proxy exposes for the FC.
6) Optional: start rl/agent_runtime.py (GCS side) to manage suite and mitigations via MQTT.

STYLE / CONTRIBUTION RULES FOR THE AI AGENT (STRICT)
- DO NOT fabricate code, paths, or results. If unknown, say “UNKNOWN: needs human input.”
- NO placeholders that pretend to be implemented. If a function is stubbed, it MUST raise NotImplementedError.
- Every new module must include a minimal self-test or unit test.
- Keep all crypto in core/*.py; wrappers in drone/gcs/wrappers must not re-implement crypto.
- All wire changes MUST update docs/PORTS_AND_FLOW.md and tests.
- NEVER weaken crypto for convenience (e.g., random nonces, skipping AAD, skipping signature).
- Always use suites.py registry for algorithm names; no hardcoded strings elsewhere.
- External references (papers/repos) must be added to docs/REFERENCES.md when first used.

DEFINITION OF DONE (DOD)
- All tests pass; end-to-end encrypt→decrypt loop verified; replay & tamper tests pass.
- Benchmarks run across the suite matrix and emit CSVs; figures regenerate.
- README shows exact commands to reproduce the demo.
- No TODO/FIXME strings in production code; stubs are isolated behind feature flags.

SECURITY NOTES
- Provision the GCS signature public key on the drone out-of-band.
- Log only metadata (session_id, suite, seq ranges, timings), never secrets or raw plaintexts.
- Ensure time-constant comparisons where needed (e.g., tags).

LICENSE & ATTRIBUTION
- Respect upstream licenses for oqs-python, cryptography, MAVLink, XGBoost, PyTorch, etc. Document in LICENSE/NOTICE.
"""
with open("/mnt/data/PROJECT_CONTEXT.txt", "w", encoding="utf-8") as f:
    f.write(context)

print("/mnt/data/PROJECT_CONTEXT.txt")
# Create a single, consolidated project context file the user can give to their GitHub Copilot agent.
# It captures architecture, directory layout, crypto invariants, ports, topics, RL, DDoS, testing,
# and strict anti-hallucination guardrails for the agent.

context = r"""
PROJECT: Quantum-Safe UAV C2 (Drone ⇄ GCS) — PQC Tunnel + DDoS Shield + RL Policy

GOAL (what “done” means)
- A reproducible, quantum-safe command/telemetry tunnel between UAV (Raspberry Pi 4B + Pixhawk 2.4.8) and GCS (PC).
- Suites covering NIST Levels L1/L3/L5 using ML-KEM (Kyber) for KEM and ML-DSA (Dilithium) / Falcon / SPHINCS+ for signature.
- Authenticated handshake; AES-GCM data plane with AAD-bound headers, 12-byte counter nonces, replay protection, safe rekey.
- Two-stage DDoS detection (Stage-1 XGBoost → Stage-2 TST) that can rate-limit/drop low-priority telemetry without affecting commands.
- Lightweight RL (contextual bandit) to select suites and mitigations under constraints (never drop below mission’s required security).
- Benchmarks + figures (latency p50/p95/p99, handshake ms/bytes, CPU%, energy/packet, DDoS ROC/PR, policy timeline).

HARDWARE / SOFTWARE
- Drone: Raspberry Pi 4B (64-bit OS), Pixhawk 2.4.8 via USB, Wi-Fi link to router.
- GCS: Linux/Windows PC (Python 3.10+; Conda env “gcs-env” ok).
- Python: liboqs via oqs-python, pyca/cryptography, pymavlink+MAVProxy, paho-mqtt, numpy/pandas, psutil, scapy, xgboost, torch (for TST).

REPO LAYOUT (single repo; both sides share core)
pqc-drone-gcs/
├─ docs/
│  ├─ OVERVIEW.md, PORTS_AND_FLOW.md, SECURITY_DESIGN.md, NIST_LEVELS.md, MEASUREMENT_METHODS.md
├─ core/                             # SINGLE source of truth for crypto & transport
│  ├─ run_proxy.py                   # CLI: --role {gcs,drone} --suite <id> --bind ... --peer ...
│  ├─ async_proxy.py                 # UDP loops, backpressure, thread/async wrappers
│  ├─ handshake.py                   # KEM + signed transcript + HKDF derivation
│  ├─ aead.py                        # AES-GCM pack/decrypt with header AAD, replay window, epochs
│  ├─ suites.py                      # registry: suite_id → {kem, sig, aead, kdf, params, nist_level}
│  ├─ config.py                      # ports, IPs, topics; env overrides; shared by both sides
│  ├─ logging_utils.py               # structured logs (JSON), metrics hooks
│  └─ utils_netem.py                 # helpers for controlled impairments in tests
├─ drone/
│  ├─ wrappers/                      # thin launchers (one file per “named suite”)
│  │  ├─ drone_kyber_512.py ... drone_sphincs_* .py (all variants call core/run_proxy.py)
│  └─ scripts/ start_suite.sh, env_check.py
├─ gcs/
│  ├─ wrappers/ (mirrors drone)      # gcs_kyber_512.py ... gcs_sphincs_*.py
│  └─ scripts/ start_suite.sh, env_check.py
├─ ddos/
│  ├─ stage1_xgb.py                  # features + XGBoost binary loading/inference
│  ├─ stage2_tst.py                  # PyTorch TST confirmatory model
│  ├─ features.py, datasets/README.md, train/*.ipynb (optional offline)
│  └─ run_ddos_daemon.py             # publishes /ddos JSON (scores, state) via MQTT
├─ rl/
│  ├─ linucb.py                      # contextual bandit
│  ├─ agent_runtime.py               # observations → action → safe switch via MQTT
│  └─ schema.py                      # JSON schema for /health and /ddos messages
├─ tools/
│  ├─ bench_cli.py, power_hooks.py, wireshark/pqc_tunnel.lua
├─ tests/
│  ├─ test_handshake.py, test_aead_framing.py, test_replay_window.py, test_rekey_epoch.py, test_loss_dup_oom.py
├─ benchmarks/ matrix.yaml, run_matrix.py, results/*.csv
├─ requirements.txt, environment.yml, README.md, LICENSE

CONFIG (core/config.py)
- This file is the single source of truth for IPs, ports, MQTT topics, and suite IDs.
- Example defaults (override with env vars or CLI):
  GCS_IP="192.168.1.10"; DRONE_IP="192.168.1.20"
  TCP_HANDSHAKE_PORT=5800                         # KEM+signature handshake over TCP
  UDP_DRONE_RX=5810; UDP_GCS_RX=5811              # encrypted data plane (UDP)
  UDP_FC_IN=14550; UDP_FC_OUT=14551               # MAVLink to/from flight controller
  MQTT_BROKER="192.168.1.5"; MQTT_PORT=1883
  TOPIC_HEALTH="/health"; TOPIC_DDOS="/ddos"
  TOPIC_ALGO_DESIRED="/algo/desired"; TOPIC_ALGO_ACK="/algo/ack"
  TOPIC_POLICY_TEL_RATE="/policy/telemetry_downsample"
  TOPIC_POLICY_LIMIT="/policy/ingress_limit"

CRYPTO INVARIANTS (NON-NEGOTIABLE)
1) Handshake must be authenticated: GCS signs transcript T = (session_id || kem_name || gcs_pub) with selected signature (Dilithium/Falcon/SPHINCS+). Drone verifies against provisioned GCS signature public key.
2) KEM → shared secret → HKDF-SHA256 → derive K_send, K_recv, nonce_seed; never use raw KEM secret directly.
3) AES-GCM with deterministic 96-bit counter nonces (per direction). Never reuse nonces.
4) Per-packet header is AAD (authenticated, not encrypted):
   version(1) | kem_id(1) | kem_param(1) | sig_id(1) | sig_param(1) | session_id(8) | seq(8) | epoch(1)
5) Sliding replay window (e.g., size 1024) per direction; drop duplicates/old.
6) Rekey periodically (by time or packets); bump epoch; safe parallel cutover (new session established before flip).
7) Minimum NIST level enforced from mission profile; never downgrade below it.

SUITES (suites.py / YAML)
- Provide these named suites (at least):
  cs-kyber512-aesgcm-dilithium2   (L1)
  cs-kyber768-aesgcm-dilithium3   (L3)  ← default
  cs-kyber1024-aesgcm-dilithium5  (L5)
  cs-kyber768-aesgcm-falcon512    (L3, smaller signatures)
  cs-kyber768-chacha20-sphincs128f (L3, conservative, larger signatures)
- Each suite defines: kem_name, sig_name, aead="AES-256-GCM", hkdf="HKDF-SHA256", nist_level, rekey_policy.

DATA PLANE (core/aead.py)
- Sender packs header (AAD), uses seq (uint64) as nonce counter → 12-byte big-endian IV.
- Receiver verifies tag with header as AAD; checks replay window; returns plaintext.
- Expose metrics (p50/p95 encrypt/decrypt μs, drops_s, rtt, loss) via /health.

DDoS (ddos/)
- Stage-1 XGBoost: cheap features computed from pre-decrypt queues: pps, burstiness, unique 5-tuples, SYN/UDP ratios, etc. Emits score ∈ [0,1].
- Stage-2 TST (PyTorch): run only when Stage-1 score exceeds threshold; confirm anomaly with short time window. Emits score ∈ [0,1].
- Combiner → ddos_state ∈ {0 ok, 1 suspect, 2 attack}; publish JSON to /ddos.
- Mitigations are executed by proxy when instructed: ingress limiter (off/2kpps/1kpps); telemetry downsample (1.0/0.7/0.4). Never throttle command path.

RL (rl/)
- Observations (normalized): cpu_pct, loss_pct, aead_p95_us, rtt_ms, xgb_score, tst_score, mission.priority, mission.min_sec.
- Actions: {suite L1/L3/L5 or L3-smallSig/L3-conservative, rekey_now, telemetry_downsample {1.0,0.7,0.4}, ingress_limit {off,2k,1k}}.
- Reward r = 2*SLA_ok − 1*CPU_norm − 0.5*loss − 0.3*p95 + 0.2*SecScore − 0.3*ddos_state − 0.1*rekey_cost.
- Safety shield: enforce mission.min_sec; freeze suite under ddos_state≥1; prioritize command channel.

TESTS (must pass before “done”)
- test_handshake: MitM swap fails; wrong signature fails; derive keys match (K_send/recv) on both sides.
- test_aead_framing: tampered header or nonce reuse → decryption fails.
- test_replay_window: duplicate/old seq dropped.
- test_rekey_epoch: epoch increments; counters reset; parallel cutover success.
- test_loss_dup_oom: tolerates 10% loss, out-of-order within window, and backpressure without deadlocks.

BENCHMARKS (benchmarks/)
- Report latency p50/p95/p99 per payload size (64/256/512/1024B), handshake ms/bytes, CPU%, mJ/packet, DDoS ROC/PR, RL reward/timeline).
- Store CSVs in benchmarks/results/ and generate all figures from CSVs.

RUN BOOK (quick start)
1) Install oqs-python + pyca/cryptography in both envs; verify core/scripts/env_check.py passes.
2) Start ddos/run_ddos_daemon.py on both sides (publishes /ddos).
3) Launch GCS proxy: python core/run_proxy.py --role gcs --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5811 --peer DRONE_IP:5810
4) Launch Drone proxy: python core/run_proxy.py --role drone --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5810 --peer GCS_IP:5811
5) Connect MAVProxy/pymavlink to local plaintext ports that the proxy exposes for the FC.
6) Optional: start rl/agent_runtime.py (GCS side) to manage suite and mitigations via MQTT.

STYLE / CONTRIBUTION RULES FOR THE AI AGENT (STRICT)
- DO NOT fabricate code, paths, or results. If unknown, say “UNKNOWN: needs human input.”
- NO placeholders that pretend to be implemented. If a function is stubbed, it MUST raise NotImplementedError.
- Every new module must include a minimal self-test or unit test.
- Keep all crypto in core/*.py; wrappers in drone/gcs/wrappers must not re-implement crypto.
- All wire changes MUST update docs/PORTS_AND_FLOW.md and tests.
- NEVER weaken crypto for convenience (e.g., random nonces, skipping AAD, skipping signature).
- Always use suites.py registry for algorithm names; no hardcoded strings elsewhere.
- External references (papers/repos) must be added to docs/REFERENCES.md when first used.

DEFINITION OF DONE (DOD)
- All tests pass; end-to-end encrypt→decrypt loop verified; replay & tamper tests pass.
- Benchmarks run across the suite matrix and emit CSVs; figures regenerate.
- README shows exact commands to reproduce the demo.
- No TODO/FIXME strings in production code; stubs are isolated behind feature flags.

SECURITY NOTES
- Provision the GCS signature public key on the drone out-of-band.
- Log only metadata (session_id, suite, seq ranges, timings), never secrets or raw plaintexts.
- Ensure time-constant comparisons where needed (e.g., tags).

LICENSE & ATTRIBUTION
- Respect upstream licenses for oqs-python, cryptography, MAVLink, XGBoost, PyTorch, etc. Document in LICENSE/NOTICE.
"""
with open("/mnt/data/PROJECT_CONTEXT.txt", "w", encoding="utf-8") as f:
    f.write(context)

"/mnt/data/PROJECT_CONTEXT.txt"

# Write the final consolidated project context file to /mnt/data
context = r"""
PROJECT: Quantum-Safe UAV C2 (Drone ⇄ GCS) — PQC Tunnel + DDoS Shield + RL Policy

GOAL (what “done” means)
- A reproducible, quantum-safe command/telemetry tunnel between UAV (Raspberry Pi 4B + Pixhawk 2.4.8) and GCS (PC).
- Suites covering NIST Levels L1/L3/L5 using ML-KEM (Kyber) for KEM and ML-DSA (Dilithium) / Falcon / SPHINCS+ for signature.
- Authenticated handshake; AES-GCM data plane with AAD-bound headers, 12-byte counter nonces, replay protection, safe rekey.
- Two-stage DDoS detection (Stage-1 XGBoost → Stage-2 TST) that can rate-limit/drop low-priority telemetry without affecting commands.
- Lightweight RL (contextual bandit) to select suites and mitigations under constraints (never drop below mission’s required security).
- Benchmarks + figures (latency p50/p95/p99, handshake ms/bytes, CPU%, energy/packet, DDoS ROC/PR, policy timeline).

HARDWARE / SOFTWARE
- Drone: Raspberry Pi 4B (64-bit OS), Pixhawk 2.4.8 via USB, Wi-Fi link to router.
- GCS: Linux/Windows PC (Python 3.10+; Conda env “gcs-env” ok).
- Python: liboqs via oqs-python, pyca/cryptography, pymavlink+MAVProxy, paho-mqtt, numpy/pandas, psutil, scapy, xgboost, torch (for TST).

REPO LAYOUT (single repo; both sides share core)
pqc-drone-gcs/
├─ docs/
│  ├─ OVERVIEW.md, PORTS_AND_FLOW.md, SECURITY_DESIGN.md, NIST_LEVELS.md, MEASUREMENT_METHODS.md
├─ core/                             # SINGLE source of truth for crypto & transport
│  ├─ run_proxy.py                   # CLI: --role {gcs,drone} --suite <id> --bind ... --peer ...
│  ├─ async_proxy.py                 # UDP loops, backpressure, thread/async wrappers
│  ├─ handshake.py                   # KEM + signed transcript + HKDF derivation
│  ├─ aead.py                        # AES-GCM pack/decrypt with header AAD, replay window, epochs
│  ├─ suites.py                      # registry: suite_id → {kem, sig, aead, kdf, params, nist_level}
│  ├─ config.py                      # ports, IPs, topics; env overrides; shared by both sides
│  ├─ logging_utils.py               # structured logs (JSON), metrics hooks
│  └─ utils_netem.py                 # helpers for controlled impairments in tests
├─ drone/
│  ├─ wrappers/                      # thin launchers (one file per “named suite”)
│  │  ├─ drone_kyber_512.py ... drone_sphincs_* .py (all variants call core/run_proxy.py)
│  └─ scripts/ start_suite.sh, env_check.py
├─ gcs/
│  ├─ wrappers/ (mirrors drone)      # gcs_kyber_512.py ... gcs_sphincs_*.py
│  └─ scripts/ start_suite.sh, env_check.py
├─ ddos/
│  ├─ stage1_xgb.py                  # features + XGBoost binary loading/inference
│  ├─ stage2_tst.py                  # PyTorch TST confirmatory model
│  ├─ features.py, datasets/README.md, train/*.ipynb (optional offline)
│  └─ run_ddos_daemon.py             # publishes /ddos JSON (scores, state) via MQTT
├─ rl/
│  ├─ linucb.py                      # contextual bandit
│  ├─ agent_runtime.py               # observations → action → safe switch via MQTT
│  └─ schema.py                      # JSON schema for /health and /ddos messages
├─ tools/
│  ├─ bench_cli.py, power_hooks.py, wireshark/pqc_tunnel.lua
├─ tests/
│  ├─ test_handshake.py, test_aead_framing.py, test_replay_window.py, test_rekey_epoch.py, test_loss_dup_oom.py
├─ benchmarks/ matrix.yaml, run_matrix.py, results/*.csv
├─ requirements.txt, environment.yml, README.md, LICENSE

CONFIG (core/config.py)
- This file is the single source of truth for IPs, ports, MQTT topics, and suite IDs.
- Example defaults (override with env vars or CLI):
  GCS_IP="192.168.1.10"; DRONE_IP="192.168.1.20"
  TCP_HANDSHAKE_PORT=5800                         # KEM+signature handshake over TCP
  UDP_DRONE_RX=5810; UDP_GCS_RX=5811              # encrypted data plane (UDP)
  UDP_FC_IN=14550; UDP_FC_OUT=14551               # MAVLink to/from flight controller
  MQTT_BROKER="192.168.1.5"; MQTT_PORT=1883
  TOPIC_HEALTH="/health"; TOPIC_DDOS="/ddos"
  TOPIC_ALGO_DESIRED="/algo/desired"; TOPIC_ALGO_ACK="/algo/ack"
  TOPIC_POLICY_TEL_RATE="/policy/telemetry_downsample"
  TOPIC_POLICY_LIMIT="/policy/ingress_limit"

CRYPTO INVARIANTS (NON-NEGOTIABLE)
1) Handshake must be authenticated: GCS signs transcript T = (session_id || kem_name || gcs_pub) with selected signature (Dilithium/Falcon/SPHINCS+). Drone verifies against provisioned GCS signature public key.
2) KEM → shared secret → HKDF-SHA256 → derive K_send, K_recv, nonce_seed; never use raw KEM secret directly.
3) AES-GCM with deterministic 96-bit counter nonces (per direction). Never reuse nonces.
4) Per-packet header is AAD (authenticated, not encrypted):
   version(1) | kem_id(1) | kem_param(1) | sig_id(1) | sig_param(1) | session_id(8) | seq(8) | epoch(1)
5) Sliding replay window (e.g., size 1024) per direction; drop duplicates/old.
6) Rekey periodically (by time or packets); bump epoch; safe parallel cutover (new session established before flip).
7) Minimum NIST level enforced from mission profile; never downgrade below it.

SUITES (suites.py / YAML)
- Provide these named suites (at least):
  cs-kyber512-aesgcm-dilithium2   (L1)
  cs-kyber768-aesgcm-dilithium3   (L3)  ← default
  cs-kyber1024-aesgcm-dilithium5  (L5)
  cs-kyber768-aesgcm-falcon512    (L3, smaller signatures)
  cs-kyber768-chacha20-sphincs128f (L3, conservative, larger signatures)
- Each suite defines: kem_name, sig_name, aead="AES-256-GCM", hkdf="HKDF-SHA256", nist_level, rekey_policy.

DATA PLANE (core/aead.py)
- Sender packs header (AAD), uses seq (uint64) as nonce counter → 12-byte big-endian IV.
- Receiver verifies tag with header as AAD; checks replay window; returns plaintext.
- Expose metrics (p50/p95 encrypt/decrypt μs, drops_s, rtt, loss) via /health.

DDoS (ddos/)
- Stage-1 XGBoost: cheap features computed from pre-decrypt queues: pps, burstiness, unique 5-tuples, SYN/UDP ratios, etc. Emits score ∈ [0,1].
- Stage-2 TST (PyTorch): run only when Stage-1 score exceeds threshold; confirm anomaly with short time window. Emits score ∈ [0,1].
- Combiner → ddos_state ∈ {0 ok, 1 suspect, 2 attack}; publish JSON to /ddos.
- Mitigations are executed by proxy when instructed: ingress limiter (off/2kpps/1kpps); telemetry downsample (1.0/0.7/0.4). Never throttle command path.

RL (rl/)
- Observations (normalized): cpu_pct, loss_pct, aead_p95_us, rtt_ms, xgb_score, tst_score, mission.priority, mission.min_sec.
- Actions: {suite L1/L3/L5 or L3-smallSig/L3-conservative, rekey_now, telemetry_downsample {1.0,0.7,0.4}, ingress_limit {off,2k,1k}}.
- Reward r = 2*SLA_ok − 1*CPU_norm − 0.5*loss − 0.3*p95 + 0.2*SecScore − 0.3*ddos_state − 0.1*rekey_cost.
- Safety shield: enforce mission.min_sec; freeze suite under ddos_state≥1; prioritize command channel.

TESTS (must pass before “done”)
- test_handshake: MitM swap fails; wrong signature fails; derive keys match (K_send/recv) on both sides.
- test_aead_framing: tampered header or nonce reuse → decryption fails.
- test_replay_window: duplicate/old seq dropped.
- test_rekey_epoch: epoch increments; counters reset; parallel cutover success.
- test_loss_dup_oom: tolerates 10% loss, out-of-order within window, and backpressure without deadlocks.

BENCHMARKS (benchmarks/)
- Report latency p50/p95/p99 per payload size (64/256/512/1024B), handshake ms/bytes, CPU%, mJ/packet, DDoS ROC/PR, RL reward/timeline.
- Store CSVs in benchmarks/results/ and generate all figures from CSVs.

RUN BOOK (quick start)
1) Install oqs-python + pyca/cryptography in both envs; verify core/scripts/env_check.py passes.
2) Start ddos/run_ddos_daemon.py on both sides (publishes /ddos).
3) Launch GCS proxy: python core/run_proxy.py --role gcs --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5811 --peer DRONE_IP:5810
4) Launch Drone proxy: python core/run_proxy.py --role drone --suite cs-kyber768-aesgcm-dilithium3 --bind 0.0.0.0:5810 --peer GCS_IP:5811
5) Connect MAVProxy/pymavlink to local plaintext ports that the proxy exposes for the FC.
6) Optional: start rl/agent_runtime.py (GCS side) to manage suite and mitigations via MQTT.

STYLE / CONTRIBUTION RULES FOR THE AI AGENT (STRICT)
- DO NOT fabricate code, paths, or results. If unknown, say “UNKNOWN: needs human input.”
- NO placeholders that pretend to be implemented. If a function is stubbed, it MUST raise NotImplementedError.
- Every new module must include a minimal self-test or unit test.
- Keep all crypto in core/*.py; wrappers in drone/gcs/wrappers must not re-implement crypto.
- All wire changes MUST update docs/PORTS_AND_FLOW.md and tests.
- NEVER weaken crypto for convenience (e.g., random nonces, skipping AAD, skipping signature).
- Always use suites.py registry for algorithm names; no hardcoded strings elsewhere.
- External references (papers/repos) must be added to docs/REFERENCES.md when first used.

DEFINITION OF DONE (DOD)
- All tests pass; end-to-end encrypt→decrypt loop verified; replay & tamper tests pass.
- Benchmarks run across the suite matrix and emit CSVs; figures regenerate.
- README shows exact commands to reproduce the demo.
- No TODO/FIXME strings in production code; stubs are isolated behind feature flags.

SECURITY NOTES
- Provision the GCS signature public key on the drone out-of-band.
- Log only metadata (session_id, suite, seq ranges, timings), never secrets or raw plaintexts.
- Ensure time-constant comparisons where needed (e.g., tags).

LICENSE & ATTRIBUTION
- Respect upstream licenses for oqs-python, cryptography, MAVLink, XGBoost, PyTorch, etc. Document in LICENSE/NOTICE.
"""
path = "/mnt/data/PROJECT_CONTEXT.txt"
with open(path, "w", encoding="utf-8") as f:
    f.write(context)

path